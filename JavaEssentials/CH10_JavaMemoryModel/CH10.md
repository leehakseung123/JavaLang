# Chapter 10 자바의 메모리 모델

---

## 자바의 메모리 모델
>java.exe가 실행되면서 자바 가상 머신이 만들어진다.  
> 자바는 메모리 공간 활용의 효율성을 높이기 위해 메모리 공간을 여러 영역으로 나누게 된다.\

![20231220182758.png](..%2F..%2F..%2F..%2FDesktop%2F20231220182758.png)
+ 메서드 영역
    >프로그램 실행에 대한 코드, 스태틱 변수 및 메서드, 런타임 상수 풀이 메서드 영역에 생성된다.  
  > 프로그램 시작 전에 로드되고 프로그램 종료 시 소렴된다.

+ 스택 영역
    > 메서드가 호출되면 지역 변수, 매개변수가 프레임 형태로 생성되어 스택 영역으로 쌓였다가 사라진다.  
  > 하나의 박스 안에서 다른 박스 안의 내용을 알 수 없다. / 프레임 영역으로 벗어난 다른 메서드의 변수들은 서로 참조 할 수 없다.
+ 힙 영역
    > 클래스의 객체(인스턴스) 배열이 new 연산자에 의해 힙 영역에 동적으로 생성된다.
---
## 디버깅하며 배우는 스택 영역 원리
→ *Ex01_MemoryInStack.java*

![2.png](..%2F..%2F..%2F..%2FDesktop%2F2.png)
> 1. 코드가 메서드 영역 내 스태틱 영역으로 옮긴다.
> 2. main() 메서드는 static 지시자가 붙어 있기 때문에 스태틱 영역으로 위치하게 된다.
>    - 스택틱 변수가 있다면 값이 대입된다
> 3. JVM은 무조건 메서드 영역 내 스태틱 영역에서 main()메서드를 첫 메서드로 실행시긴다.  
> (만약 스태틱 영역에 옮겨진 main()이 없다면 프로그램은 실행되지 않는다.\)  
> 4. JVM에 전달한 클래스에는 main()메서드가 반드시 있어야 하고  publ  c으로 접근 가능해야 한다.)  
> +  자바 프로그램 실행 가능

###  static (전역변수)
  + 자바의 메모리 모델 구조에 의해 단지 먼저 추려내져야 하는 변수와 메서드가 있다면 static 지시자 표시를 하여 메모리의 특정 영역에 따로,
   그리고 미리 로딩시켜놓는다.
  + 이 영역에 변수 및 메서드는 어떤 객체에서도 접근하여 사용가능하다.

___

## 디버깅하며 배우는 힙 영역 원리
*→ Ex02_MemoryInHelp1.java*
+ 위 예제는 객체를 만들어 Book 클래스형 book1 변수에 대입해주고 있다.
+ 먼저 new 연산자와 Book() 생성자를 이용하여 객체를 힙 영역에 만든다

  | id |   class    |힙 위지|
  |:--:|:----------:|:--:|
  | 20 | String\[0] |0x~~~~~(메모리 주소)|
   | 27 |    Book    |0x~~~~~(메모리 주소)|
+ 생성되는 객체 크기는 클래스마다 천차만별이라 힙 영역에 동적으로 만들어 저장한다.
  + 스택영역에는 기본 자료형처럼 정해진 크기의 값들만 저장하게 된다.

### 가비지 컬렉션 (garbage collection)
>+ 가비지 컬렉션이 수행되는 동안에는 모든 스레드가 멈추게 된다.  
>  + ``System.gc()`` : 가비지 컬렉션을 강제로 발생시키는 코드  
>
>+ 가비지 컬렉션이 발생하면, 소멸 대상이 되는 인스턴스는 결정되지만 곧바로 실제 소멸되지는 않는다.  </br>인스턴스의 실제 소멸로 이어지지 않은 상테에서도 프로그램이 종료될 수 있다. </br> 종료가 되면 어차피 객체는 운영체제에 의해 소멸된다.
>+ ``System.runFinalization();`` 코드를 삽입하여 객체의 소멸을 이끈다.
>+ 가비지 컬렉션은 프로그래머가 객체가 필요 없어지는 시점을 알더라도 메모리에서 직접 해체할 수 없고, </br> 가비지 컬렉션의 알고리즘이 메모리 해제 시점을 계속 추적하고 판단하게 되므로 추가적은 시스템 비용이 발생하게 된다.
>+ 가비지 컬레션이 실행되는 시각이나 수행 시간을 알 수 없기 때문에 실시간 시스템에서 프로그램이 예측 불가능하게 잠시라도 정지할 수 있어 매우 위험하다.
---
## 디버깅하며 배우는 힙 영역 객체 참조
*→ Ex03_MemoryInHeap.java*

>![3.png](..%2F..%2F..%2F..%2FDesktop%2F3.png)
> 힙 영역에 객체를 새로 만드는 것이 아니고, 기존 객체를 가리키는 변수만 하나 늘어난다.
> 하나의 객체를 여러 변수가 참조할 수 있다.  
> 가비지 컬렉터는 이런 참조가 하나도 없는 힙 영역의 객체를 제거 대상으로 삼는다.